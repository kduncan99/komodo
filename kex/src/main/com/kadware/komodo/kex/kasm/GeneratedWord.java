/*
 * Copyright (c) 2018-2020 by Kurt Duncan - All Rights Reserved
 */

package com.kadware.komodo.kex.kasm;

import com.kadware.komodo.baselib.Word36;
import com.kadware.komodo.kex.RelocatableModule;
import com.kadware.komodo.kex.kasm.dictionary.IntegerValue;

/**
 * Describes a single word which has been generated by the assembler,
 * complete with attached information regarding any relocations which need to be applied.
 */
@SuppressWarnings("Duplicates")
class GeneratedWord {

    final TextLine _topLevelTextLine;
    final LineSpecifier _lineSpecifier;
    final int _locationCounterIndex;
    final int _locationCounterOffset;
    final IntegerValue _value;

    /**
     * Tracks the location of the line of source code which produced this object
     * @param topLevelTextLine reference to the TextLine object responsible for generating this word
     * @param lineSpecifier line specifier of the line of source code which directly produced this word
     * @param locationCounterIndex what pool contains this
     * @param locationCounterOffset where is this within that pool
     * @param value IntegerValue defining the the various field values and references for this word
     */
    GeneratedWord(
        final TextLine topLevelTextLine,
        final LineSpecifier lineSpecifier,
        final int locationCounterIndex,
        final int locationCounterOffset,
        final IntegerValue value
    ) {
        _lineSpecifier = lineSpecifier;
        _topLevelTextLine = topLevelTextLine;
        _locationCounterIndex = locationCounterIndex;
        _locationCounterOffset = locationCounterOffset;
        _value = value;
    }

    /**
     * Sometimes we need to change the IntegerValue object
     */
    GeneratedWord copy(
        final IntegerValue newValue
    ) {
        return new GeneratedWord(_topLevelTextLine, _lineSpecifier, _locationCounterIndex, _locationCounterOffset, newValue);
    }

    /**
     * Constructs a RelocatableWord object based upon the given IntegerValue.
     * Should be called after we've resolved all references local to the containing module.
     */
    RelocatableModule.RelocatableWord produceRelocatableWord() {
        RelocatableModule.RelocatableItem[] relItems = new RelocatableModule.RelocatableItem[_value._references.length];
        for (int urx = 0; urx < _value._references.length; ++urx) {
            UndefinedReference ur = _value._references[urx];
            if (ur instanceof UndefinedReferenceToLabel) {
                UndefinedReferenceToLabel url = (UndefinedReferenceToLabel) ur;
                relItems[urx] = new RelocatableModule.RelocatableItemSymbol(url._label,
                                                                            url._fieldDescriptor,
                                                                            url._isNegative);
            } else if (ur instanceof UndefinedReferenceToLocationCounter) {
                UndefinedReferenceToLocationCounter urlc = (UndefinedReferenceToLocationCounter) ur;
                relItems[urx] = new RelocatableModule.RelocatableItemLocationCounter(urlc._locationCounterIndex,
                                                                                     urlc._fieldDescriptor,
                                                                                     urlc._isNegative);
            }
        }

        //  TODO should we verify that _value is within 36 bits?
        return new RelocatableModule.RelocatableWord(new Word36(_value._value.get().longValue()), relItems);
    }
}
